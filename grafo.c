/*Nomes : Arthur Alexsander Martins Teodoro           Matrícula : 0022427*/
/*        Saulo Ricardo Dias Fernandes                Matrícula : 0021581*/
/*Data: 10/05/2016*/

/*======================================================================================*/
/*=======================================BIBLIOTECAS====================================*/
/*======================================================================================*/
#include "grafo.h"
#include <stdio.h>
#include <stdlib.h>

struct aresta
{
  int partida;
  int chegada;
  int identificador;
};

struct grafo
{
	int V;
	int A;
	int aMax;
	int vMax;
  struct aresta *arestas;
	int *vertices;
};

/*======================================================================================*/
/*===============================FUNÇÕES-DO-TRABALHO====================================*/
/*======================================================================================*/


/*======================================================================================
CRIA GRAFO
IN : INT V, INT A;
OUT : P (PONTEIRO PARA O GRAFO)
======================================================================================*/
Grafo GGcriaGrafo(int v, int a)
{
	if(v > 0 && a > 0)
	{
		Grafo p = (Grafo) malloc(sizeof(struct grafo));
		p->V = 0;
		p->A = 0;
		p->aMax = a;
		p->vMax = v;
		p->vertices = (int*) malloc(sizeof(int)*v);
		p->arestas = (struct aresta*) malloc(sizeof(struct aresta)*a);
		return p;
	}
	return NULL;
}
/*======================================================================================*/

/*========================================================================================
DESTROI GRAFO
IN : P
OUT : P NULL
========================================================================================*/
Grafo GGdestroiGrafo(Grafo p)
{
  free(p->arestas);
  free(p->vertices);
	free(p);
	return NULL;
}
/*======================================================================================*/

/*========================================================================================
CRIA VERTICE
IN : P
OUT : V (INDENTIFICADOR DO VERTICE)
========================================================================================*/
int GVcriaVertice(Grafo p)
{
	if(p->V < p->vMax)
	{ 
  	p->vertices[p->V] = p->V + 1;
  	p->V++;
  	return p->vertices[p->V-1];
	}
	return 0;
}
/*======================================================================================*/

/*========================================================================================
CRIA ARESTA
IN : P (PONTEIRO PARA UM GRAFO), V1(VERTICE DE PARTIDA), V2(VERTICE CHEGADA)
OUT : A (IDENTIFICADOR ARESTA)
========================================================================================*/
int GAcriaAresta(Grafo p, int v1, int v2)
{
	if((GBexisteIdVertice(p,v1)&&(GBexisteIdVertice(p,v2)))&&(p->A < p->aMax))
	{
		p->arestas[p->A].partida = v1;
		p->arestas[p->A].chegada = v2;
		p->arestas[p->A].identificador = p->A+1;
		p->A++;
		return p->arestas[p->A-1].identificador;
	}
	return 0;
}
/*======================================================================================*/

/*========================================================================================
EXISTE VERTICE
IN : P, V
OUT : B (BOOLEAN)
========================================================================================*/
int GBexisteIdVertice(Grafo p, int v)
{
	int i;
	for(i = 0; i < p->V; i++)
	{
		if(v == p->vertices[i])
		{
			return 1;
		}
	}
	return 0;
}
/*======================================================================================*/

/*========================================================================================
EXISTE ARESTA
IN : P, 
OUT : B
========================================================================================*/
int GBexisteIdAresta(Grafo p, int a)
{
	int i;
	for(i = 0; i < p->A; i++)
	{
		if(a == p->arestas[i].identificador)
		{
			return 1;
		}
	}
	return 0;
}
/*======================================================================================*/

/*========================================================================================
EXISTE ARESTA DIRIGIDA
IN : P, V1, V2
OUT : B
========================================================================================*/
int GBexisteArestaDir(Grafo p, int v1, int v2)
{
	int i;
	for(i = 0; i < p->A; i++)
	{
		if((v1 == p->arestas[i].partida)&&(v2 == p->arestas[i].chegada))
		{
			return 1;
		}
	}
	return 0;
}
/*======================================================================================*/

/*========================================================================================
EXISTE ARESTA NAO DIRIGIDA
IN : P, V1, V2
OUT : B
========================================================================================*/
int GBexisteAresta(Grafo p, int v1, int v2)
{
	int i;
	for(i = 0; i < p->A; i++)
	{
		if(((v1 == p->arestas[i].partida)&&(v2 == p->arestas[i].chegada))||
			 ((v2 == p->arestas[i].partida)&&(v1 == p->arestas[i].chegada)))
		{
			return 1;
		}
	}
	return 0;
}
/*======================================================================================*/

/*========================================================================================
PEGA ID DE UMA ARESTA DIRIGIDA
IN : P, V1, V2
OUT : A
========================================================================================*/
int GApegaArestaDir(Grafo p, int v1, int v2)
{
	int i;
	for(i = 0; i < p->A; i++)
	{
		if((v1 == p->arestas[i].partida)&&(v2 == p->arestas[i].chegada))
		{
			return p->arestas[i].identificador;
		}
	}
	return 0;
}
/*======================================================================================*/

/*========================================================================================
PEGA ID DE UMA ARESTA NAO DIRIGIDA
IN : P, V1, V2
OUT : A
========================================================================================*/
int GApegaAresta(Grafo p, int v1, int v2)
{
	int i;
	for(i = 0; i < p->A; i++)
	{
		if(((v1 == p->arestas[i].partida)&&(v2 == p->arestas[i].chegada))||
			 ((v2 == p->arestas[i].partida)&&(v1 == p->arestas[i].chegada)))
		{
			return p->arestas[i].identificador;
		}
	}
	return 0;
}
/*======================================================================================*/

/*========================================================================================
PEGA O 1º VERTICE
IN : P
OUT : V
========================================================================================*/
int GVprimeiroVertice(Grafo p)
  {
  	if(p->V > 0)
  	{
    	return p->vertices[0];
    }
    return 0;  
  }
/*======================================================================================*/

/*========================================================================================
PEGA O PROXIMO VERTICE
IN : P, V1
OUT : V2
========================================================================================*/

/*======================================================================================*/
int GVproximoVertice(Grafo p, int v1)
{
	if(p->V > v1)
	{
		return p->vertices[v1];
	}
	return 0;
}
/*========================================================================================
PEGA A PRIMEIRA ARESTA
IN : P
OUT : A
========================================================================================*/
int GAprimeiraAresta(Grafo p)
 {
  	if(p->A > 0)
  	{
    	return p->arestas[0].identificador;
    }
    return 0;  
 }
/*======================================================================================*/

/*========================================================================================
PEGA A PROXIMA ARESTA
IN : P, A1
OUT : A2
========================================================================================*/
int GAproximaAresta(Grafo p, int a1)
 {
  	if(p->A > a1)
  	{
    	return p->arestas[a1].identificador;
    }
    return 0;  
 }
/*======================================================================================*/

/*========================================================================================
PEGA NUMEROS DE VERTICES
IN : P
OUT : NV(NUMERO DE VERTICES)
========================================================================================*/
int GInumeroVertices(Grafo p)
 {
  	if(p->V > 0)
  	{
    	return p->V;
   	}
    return 0;  
 }
/*======================================================================================*/

/*========================================================================================
PEGA NUMERO MAXIMO DE VERTICES
IN : P
OUT : NV
========================================================================================*/
int GInumeroVerticesMax(Grafo p)
  {
  	if(p->V > 0)
  	{
    	return p->vMax;
    }
    return 0;  
  }
/*======================================================================================*/

/*========================================================================================
PEGA NUMERO DE ARESTAS
IN : P
OUT : NA(NUMERO DE ARESTAS)
========================================================================================*/
int GInumeroArestas(Grafo p)
  {
  	if(p->A > 0)
  	{
    	return p->A;
    }
    return 0;  
  }
/*======================================================================================*/

/*========================================================================================
PEGA NUMERRO MAXIMO DE ARESTAS
IN : P
OUT : NA
========================================================================================*/
int GInumeroArestasMax(Grafo p)
  {
  	if(p->A > 0)
  	{
    	return p->aMax;
    }
    return 0;
  }
/*======================================================================================*/

/*========================================================================================
CRIA E CARREGA GRAFO
IN : F(NOME DO ARQUIVO QUE CONTEM O GRAFO)
OUT : P
========================================================================================*/
Grafo GGcarregaGrafo(char *f)
{
	FILE *fp;
	fp = fopen(f,"rt");
	if(fp == NULL)
	{
		return NULL;
	}	
	int v1, v2, i = 0;;
	fscanf(fp,"%d%d",&v1,&v2);
	Grafo p = GGcriaGrafo(v1,v2);
	for(i = 0; i < v1; i++)
	{
		GVcriaVertice(p);
	}
	while(fscanf(fp,"%d%d",&v1,&v2) != EOF)
	{
		GAcriaAresta(p,v1,v2);
	}
	fclose(fp);
	return p;
}  
/*======================================================================================*/

/*========================================================================================
SALVA GRAFO EM UM ARQUIVO
IN : P, F
OUT : B
========================================================================================*/
int GBsalvaGrafo(Grafo p, char *f)
{
	FILE *fp;
	fp = fopen(f,"wt");
	fprintf(fp, "%d %d\n", GInumeroVerticesMax(p), GInumeroArestasMax(p));
	int i;
	for(i = GAprimeiraAresta(p); i != 0; i = GAproximaAresta(p,i))
  {
  	fprintf(fp,"%d %d\n", GValfa(p,i),GVomega(p,i));
  }
	fclose(fp);
	return 0;
}
/*======================================================================================*/

/*========================================================================================
PEGA O GRAU DO VERTICE
IN : P, V 
OUT : I(GRAU DO VERTICE)
========================================================================================*/
int GIpegaGrau(Grafo p, int v)
{
	int i, grau = 0;
	for(i = 0; i < p->A; i++)
	{
		if(p->arestas[i].partida == v)
		{
			grau++;
		}
		if(p->arestas[i].chegada == v)
		{
			grau++;
		}
	}
	return grau;
}
/*======================================================================================*/

/*========================================================================================
PEGA 1ª ARESTA NA ESTRELA DO VERTICE EM GRAFO NAO DIRIGIDO
IN : P, V
OUT : A1
========================================================================================*/
int GAprimaAresta(Grafo p, int v)
{
	int i;
	for(i = 0; i < p->A; i++)
	{
		if((v == p->arestas[i].partida)||(v == p->arestas[i].chegada))
		{
			return p->arestas[i].identificador;
		}
	}
	return 0;
}
/*======================================================================================*/

/*========================================================================================
PEGA PROX ARESTA NA ESTRELA DO VERTICE EM GRAFO N DIR
IN : P, V, A1
OUT : A2
========================================================================================*/
int GAproxAresta(Grafo p, int v, int a1)
{
	int i;
	for(i = 0; i < p->A; i++)
	{
		if(((v == p->arestas[i].partida)&&(a1 < p->arestas[i].identificador))||
			 ((v == p->arestas[i].chegada)&&(a1 < p->arestas[i].identificador)))
		{
			return p->arestas[i].identificador;
		}
	}
	return 0;
}
/*======================================================================================*/

/*========================================================================================
PEGA 1ª ARESTA NA ESTRELA DO VERTICE EM GRAFO DIRIGIDO	
IN : P,V
OUT : A1
========================================================================================*/
int GAprimaEntrada(Grafo p, int v)
{
	int i;
	for(i = 0; i < p->A; i++)
	{
		if(v == p->arestas[i].chegada)
		{
			return p->arestas[i].identificador;
		}
	}
	return 0;
}
/*======================================================================================*/

/*========================================================================================
PEGA PROX ARESTA NA ESTRELA DO VERTICE EM GRAFO DIR
IN : P, V, A1
OUT : A2
========================================================================================*/
int GAproxEntrada(Grafo p, int v, int a1)
{
	int i;
	for(i = 0; i < p->A; i++)
	{
		if((v == p->arestas[i].chegada)&&(a1 < p->arestas[i].identificador))
		{
			return p->arestas[i].identificador;
		}
	}
	return 0;
}
/*======================================================================================*/

/*========================================================================================
PEGA A 1ª ARESTA NA ESTRELA DE SAIDA DO VERTICE EM GRAFOS DIRIGIDOS
IN : P, V
OUT : A1
========================================================================================*/
int GAprimaSaida(Grafo p, int v)
{
	int i;
	for(i = 0; i < p->A; i++)
	{
		if(v == p->arestas[i].partida)
		{
			return p->arestas[i].identificador;
		}
	}
	return 0;
}
/*======================================================================================*/

/*========================================================================================
PEGA A PROX ARESTA NA ESTRELA DE SAIDA DO VERT. EM GRAF. DIR.
IN : P, V, A1
OUT : A2
========================================================================================*/
int GAproxSaida(Grafo p, int v, int a1)
{
	int i;
	for(i = 0; i < p->A; i++)
	{
		if((v == p->arestas[i].partida)&&(a1 < p->arestas[i].identificador))
		{
			return p->arestas[i].identificador;
		}
	}
	return 0;
}
/*======================================================================================*/

/*========================================================================================
DADA UMA ARESTA, É UM LAÇO ?
IN : P, A
OUT : B
========================================================================================*/
int GBarestaLaco(Grafo p, int a)
{
	if(a <= p->A)
	{
		if(p->arestas[a-1].partida == p->arestas[a-1].chegada)
		{
			return 1;
		}
		return 0;
	}
	return 0;
}
/*======================================================================================*/

/*========================================================================================
PEGA VERTICE DE SAIDA DA ARESTA
IN : P, A
OUT : V
========================================================================================*/
int GValfa(Grafo p, int a)
{
	if(a <= p->A)
	{
		return p->arestas[a-1].partida;
	}
	return 0;
}
/*======================================================================================*/

/*========================================================================================
PEGA VERTICE CHEGADA DA ARESTA
IN : P, A
OUT : V
========================================================================================*/
int GVomega(Grafo p, int a)
{
	if(a <= p->A)
	{
		return p->arestas[a-1].chegada;
	}
	return 0;
}
/*======================================================================================*/

/*========================================================================================
PEGA O OUTRO VERTICE NO EXTREMO DA ARESTA 
IN : P, A, V1
OUT : V2
========================================================================================*/
int GVvizinho(Grafo p, int a, int v1)
{
	if(a <= p->A && v1 <= p->V)
	{
		if(p->arestas[a-1].partida == v1)
		{
			return p->arestas[a-1].chegada;
		}
		if(p->arestas[a-1].chegada == v1)
		{
			return p->arestas[a-1].partida;
		}
	}
	return 0;
}
/*======================================================================================*/
